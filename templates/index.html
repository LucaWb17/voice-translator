<!-- templates/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Traduttore Vocale Bidirezionale</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        body {
            padding-top: 20px;
            background-color: #f8f9fa;
        }
        .card {
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,.1);
        }
        .card-header {
            background-color: #f1f8ff;
        }
        .translation-card {
            margin: 10px 0;
            border-left: 4px solid #007bff;
        }
        .persona-a {
            border-left-color: #28a745;
        }
        .persona-b {
            border-left-color: #dc3545;
        }
        .status-indicator {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 5px;
        }
        .status-active {
            background-color: #28a745;
            animation: pulse 2s infinite;
        }
        .status-inactive {
            background-color: #dc3545;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        #historyContainer {
            max-height: 500px;
            overflow-y: auto;
        }
        .audio-control {
            cursor: pointer;
            color: #007bff;
        }
        .config-card {
            background-color: #fff;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="row mb-4">
            <div class="col text-center">
                <h1><i class="fas fa-language"></i> Traduttore Vocale Bidirezionale</h1>
                <p class="lead">Traduzione in tempo reale per conversazioni multilingue</p>
            </div>
        </div>

        <!-- Status and Control -->
        <div class="row mb-4">
            <div class="col-md-6 mx-auto">
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h5 class="mb-0">
                            <span id="statusIndicator" class="status-indicator status-inactive"></span>
                            <span id="statusText">Sistema inattivo</span>
                        </h5>
                        <div>
                            <button id="startButton" class="btn btn-success">
                                <i class="fas fa-play"></i> Avvia
                            </button>
                            <button id="stopButton" class="btn btn-danger" disabled>
                                <i class="fas fa-stop"></i> Ferma
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Configuration -->
        <div class="row mb-4">
            <div class="col-md-6">
                <div class="card config-card">
                    <div class="card-header">
                        <h5><i class="fas fa-user"></i> Persona A</h5>
                    </div>
                    <div class="card-body">
                        <div class="mb-3">
                            <label for="personA_target_language" class="form-label">Lingua di ascolto:</label>
                            <select id="personA_target_language" class="form-select">
                                {% for language in available_languages %}
                                <option value="{{ language }}" {% if language == config.personA_target_language %}selected{% endif %}>{{ language }}</option>
                                {% endfor %}
                            </select>
                        </div>
                        <div class="mb-3">
                            <label for="voiceA" class="form-label">Voce:</label>
                            <select id="voiceA" class="form-select">
                                {% for voice in available_voices.English %}
                                <option value="{{ voice }}" {% if voice == config.voiceA %}selected{% endif %}>{{ voice }}</option>
                                {% endfor %}
                            </select>
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="card config-card">
                    <div class="card-header">
                        <h5><i class="fas fa-user-friends"></i> Persona B</h5>
                    </div>
                    <div class="card-body">
                        <div class="mb-3">
                            <label for="personB_target_language" class="form-label">Lingua di ascolto:</label>
                            <select id="personB_target_language" class="form-select">
                                {% for language in available_languages %}
                                <option value="{{ language }}" {% if language == config.personB_target_language %}selected{% endif %}>{{ language }}</option>
                                {% endfor %}
                            </select>
                        </div>
                        <div class="mb-3">
                            <label for="voiceB" class="form-label">Voce:</label>
                            <select id="voiceB" class="form-select">
                                {% for voice in available_voices.German %}
                                <option value="{{ voice }}" {% if voice == config.voiceB %}selected{% endif %}>{{ voice }}</option>
                                {% endfor %}
                            </select>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Translation History -->
        <div class="row">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">
                        <h5><i class="fas fa-history"></i> Cronologia Traduzioni</h5>
                    </div>
                    <div class="card-body">
                        <div id="historyContainer">
                            <div class="text-center text-muted" id="emptyHistoryMessage">
                                <i class="fas fa-comment-slash fa-3x mb-3"></i>
                                <p>Avvia una sessione per vedere le traduzioni</p>
                            </div>
                            <div id="translationHistory"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>

    <!-- JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script>
// Replace the JavaScript section in your index.html with this code

// Global variables
let activeSession = false;
let lastTimestamp = 0;
let socket;
let audioContext;
let mediaStream;
let mediaRecorder;
let audioProcessor;
let audioQueue = [];
let isProcessingAudio = false;

// DOM elements
const startButton = document.getElementById('startButton');
const stopButton = document.getElementById('stopButton');
const statusIndicator = document.getElementById('statusIndicator');
const statusText = document.getElementById('statusText');
const translationHistory = document.getElementById('translationHistory');
const emptyHistoryMessage = document.getElementById('emptyHistoryMessage');

// Form elements
const personA_language = document.getElementById('personA_target_language');
const personB_language = document.getElementById('personB_target_language');
const voiceA = document.getElementById('voiceA');
const voiceB = document.getElementById('voiceB');

// Initialize Socket.IO connection
function initializeSocket() {
    // Connect to the server with proper options
    const socketUrl = window.location.origin;
    socket = io(socketUrl, {
        reconnectionDelayMax: 10000,
        reconnectionAttempts: 10
    });

    // Socket event handlers
    socket.on('connect', () => {
        console.log('Socket.IO connected!');
    });

    socket.on('disconnect', () => {
        console.log('Socket.IO disconnected');
    });

    socket.on('connect_error', (error) => {
        console.error('Socket.IO connection error:', error);
    });

    socket.on('new_translation', (entry) => {
        console.log('Received new translation:', entry);
        addTranslationToHistory(entry);
        lastTimestamp = Math.max(lastTimestamp, entry.timestamp);
    });
}

// Initialize audio recording
async function initializeAudio() {
    try {
        // Request microphone access
        mediaStream = await navigator.mediaDevices.getUserMedia({ 
            audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true
            }
        });
        
        console.log('Microphone access granted');
        
        // Create audio context
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Create media recorder with appropriate MIME type and settings
        let options = {};
        if (MediaRecorder.isTypeSupported('audio/webm')) {
            options = { mimeType: 'audio/webm' };
        } else if (MediaRecorder.isTypeSupported('audio/mp4')) {
            options = { mimeType: 'audio/mp4' };
        }
        
        mediaRecorder = new MediaRecorder(mediaStream, options);
        
        // Handle recorded data
        mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0 && socket && socket.connected && activeSession) {
                // Convert Blob to ArrayBuffer for transmission
                event.data.arrayBuffer().then(buffer => {
                    socket.emit('audio', buffer);
                });
            }
        };
        
        console.log('MediaRecorder initialized');
        
    } catch (error) {
        console.error('Error initializing audio:', error);
        alert('Failed to access your microphone. Please check your browser permissions.');
    }
}

// Event listeners for language changes
personA_language.addEventListener('change', updateVoiceOptions);
personB_language.addEventListener('change', updateVoiceOptions);

// Function to update voice options based on selected language
function updateVoiceOptions() {
    // Update voiceA options based on personA_language
    const langA = personA_language.value;
    voiceA.innerHTML = '';
    if (voiceOptions[langA]) {
        voiceOptions[langA].forEach(voice => {
            const option = document.createElement('option');
            option.value = voice;
            option.textContent = voice;
            voiceA.appendChild(option);
        });
    } else {
        // Default to English voices if no specific voices for the language
        voiceOptions['English'].forEach(voice => {
            const option = document.createElement('option');
            option.value = voice;
            option.textContent = voice;
            voiceA.appendChild(option);
        });
    }

    // Update voiceB options based on personB_language
    const langB = personB_language.value;
    voiceB.innerHTML = '';
    if (voiceOptions[langB]) {
        voiceOptions[langB].forEach(voice => {
            const option = document.createElement('option');
            option.value = voice;
            option.textContent = voice;
            voiceB.appendChild(option);
        });
    } else {
        // Default to English voices if no specific voices for the language
        voiceOptions['English'].forEach(voice => {
            const option = document.createElement('option');
            option.value = voice;
            option.textContent = voice;
            voiceB.appendChild(option);
        });
    }

    // Save configuration
    saveConfig();
}

// Function to save configuration
function saveConfig() {
    const config = {
        personA_target_language: personA_language.value,
        personB_target_language: personB_language.value,
        voiceA: voiceA.value,
        voiceB: voiceB.value
    };

    fetch('/api/config', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(config)
    })
    .then(response => response.json())
    .then(data => {
        console.log('Configuration saved:', data);
    })
    .catch(error => {
        console.error('Error saving configuration:', error);
    });
}

// Start/stop recording functions
function startRecording() {
    if (mediaRecorder && mediaRecorder.state !== 'recording') {
        mediaRecorder.start(250); // Send data every 250ms
        console.log('Started recording');
    }
}

function stopRecording() {
    if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
        console.log('Stopped recording');
    }
}

// Event listeners for start/stop buttons
startButton.addEventListener('click', startSession);
stopButton.addEventListener('click', stopSession);

// Function to start translation session
function startSession() {
    saveConfig();
    
    fetch('/api/start_session', {
        method: 'POST'
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            activeSession = true;
            updateUIForActiveSession();
            startPollingHistory();
            startRecording();
        } else {
            alert('Error: ' + data.message);
        }
    })
    .catch(error => {
        alert('Connection error: ' + error);
    });
}

// Function to stop translation session
function stopSession() {
    stopRecording();
    
    fetch('/api/stop_session', {
        method: 'POST'
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            activeSession = false;
            updateUIForInactiveSession();
        } else {
            alert('Error: ' + data.message);
        }
    })
    .catch(error => {
        alert('Connection error: ' + error);
    });
}

// Update UI for active session
function updateUIForActiveSession() {
    startButton.disabled = true;
    stopButton.disabled = false;
    statusIndicator.classList.remove('status-inactive');
    statusIndicator.classList.add('status-active');
    statusText.textContent = 'Translation active';
    personA_language.disabled = true;
    personB_language.disabled = true;
    voiceA.disabled = true;
    voiceB.disabled = true;
}

// Update UI for inactive session
function updateUIForInactiveSession() {
    startButton.disabled = false;
    stopButton.disabled = true;
    statusIndicator.classList.remove('status-active');
    statusIndicator.classList.add('status-inactive');
    statusText.textContent = 'System inactive';
    personA_language.disabled = false;
    personB_language.disabled = false;
    voiceA.disabled = false;
    voiceB.disabled = false;
}

// Poll for new translations
function startPollingHistory() {
    if (!activeSession) return;

    fetch(`/api/translation_history?since=${lastTimestamp}`)
        .then(response => response.json())
        .then(data => {
            if (data.length > 0) {
                // Hide empty history message if there are translations
                emptyHistoryMessage.style.display = 'none';
                
                // Add new translations to the history
                data.forEach(entry => {
                    addTranslationToHistory(entry);
                    lastTimestamp = Math.max(lastTimestamp, entry.timestamp);
                });
            }
            
            // Continue polling if session is active
            if (activeSession) {
                setTimeout(startPollingHistory, 1000);
            }
        })
        .catch(error => {
            console.error('Error polling history:', error);
            if (activeSession) {
                setTimeout(startPollingHistory, 2000);
            }
        });
}

// Add a translation entry to the history display
function addTranslationToHistory(entry) {
    const card = document.createElement('div');
    card.className = `card translation-card ${entry.persona === 'A' ? 'persona-a' : 'persona-b'}`;
    
    const time = new Date(entry.timestamp * 1000).toLocaleTimeString();
    
    card.innerHTML = `
        <div class="card-body">
            <div class="d-flex justify-content-between align-items-start">
                <h6 class="card-subtitle mb-2 text-muted">
                    Person ${entry.persona} - ${time}
                </h6>
                <span class="badge ${entry.persona === 'A' ? 'bg-success' : 'bg-danger'}">
                    ${entry.persona === 'A' ? 'A → B' : 'B → A'}
                </span>
            </div>
            <p class="card-text mb-1">
                <strong>Original (${entry.detected_language}):</strong> ${entry.original_text}
            </p>
            <p class="card-text">
                <strong>Translation (${entry.target_language}):</strong> ${entry.translated_text}
                <i class="fas fa-volume-up ms-2 audio-control" 
                   onclick="playAudio('${entry.audio_b64}')" 
                   title="Play audio"></i>
            </p>
        </div>
    `;
    
    // Add to the top of the history
    translationHistory.insertBefore(card, translationHistory.firstChild);
}

// Function to play audio from base64
function playAudio(audioBase64) {
    const audio = new Audio(`data:audio/mp3;base64,${audioBase64}`);
    audio.play();
}

// Initialize
async function init() {
    console.log('Initializing application...');
    
    // Initialize Socket.IO connection
    initializeSocket();
    
    // Initialize audio recording
    await initializeAudio();
    
    // Call once to set up initial voice options
    updateVoiceOptions();
    
    // Check if there's an active session
    fetch('/api/config')
        .then(response => response.json())
        .then(data => {
            if (data.session_active) {
                activeSession = true;
                updateUIForActiveSession();
                startPollingHistory();
                startRecording();
            }
        })
        .catch(error => {
            console.error('Error fetching config:', error);
        });
        
    console.log('Application initialization complete');
}

// Parse voice options from the server
var voiceOptions = JSON.parse('{{ available_voices|tojson|safe }}');

// Start initialization when page loads
window.addEventListener('load', init);
    </script>
</body>
</html>
